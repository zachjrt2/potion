<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Witchy Potion Mixer</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>The Witches Tower</h1>
        <p class="subtitle">Find ingredients in the word search, brew mystical potions, and grow your tower</p>

        <div class="nav-tabs">
            <button class="tab-btn active" onclick="switchTab('search')">Word Search</button>
            <button class="tab-btn" onclick="switchTab('mixer')">Potion Mixer</button>
            <button class="tab-btn" onclick="switchTab('tower')">Tower</button>
        </div>

        <div id="searchPage" class="page active">
            <div class="word-search-layout">
                <div class="panel">
                    <h2>Find the Ingredients</h2>
                    <div class="progress-bar">
                        <span id="progressText">Found: 0 / 20</span>
                    </div>
                    <div class="grid-container" id="wordGrid"></div>
                    <button class="regenerate-btn" onclick="regenerateGrid()">Generate New Puzzle</button>
                    <button class="regenerate-btn" onclick="clearProgress()" style="background: #8b4444; margin-top: 10px;">Clear All Progress</button>
                </div>
                <div class="panel">
                    <h2>Current Puzzle</h2>
                    <div class="words-list" id="wordsList"></div>
                </div>
            </div>
        </div>

        <div id="mixerPage" class="page">
            <div class="main-grid">
                <div class="panel">
                    <h2>Ingredients</h2>
                    <div class="ingredients-grid" id="ingredientsGrid"></div>
                    <button class="mix-button" id="mixButton" disabled>Mix Potion</button>
                    <div class="export-buttons">
                        <button class="export-btn" onclick="exportEncrypted()">Export (Encrypted)</button>
                        <button class="export-btn" onclick="exportDummy()">Export (Plain)</button>
                    </div>
                </div>

                <div class="panel">
                    <h2>Your Potions <span id="potionCount" class="potion-count"></span></h2>
                    <div class="potion-list" id="potionList">
                        <div class="empty-state">No potions brewed yet. Unlock ingredients and mix!</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<div id="towerPage" class="page">
    <div class="tower-container">
        <canvas id="towerCanvas" class="tower-canvas" width="300" height="800"></canvas>
    </div>
    <div class="tower-stats">
        <div><span class="stat-label">Tower Height:</span> <span class="stat-value" id="towerHeight">0</span> <span class="stat-label">rows</span></div>
        <div><span class="stat-label">Total Blocks:</span> <span class="stat-value" id="totalBlocks">0</span></div>
        <div><span class="stat-label">Spendable Blocks:</span> <span class="stat-value" id="spendableBlocks">0</span></div>
        <div><span class="stat-label">Towers Completed:</span> <span class="stat-value" id="towersCompleted">0</span></div>
        <div><span class="stat-label">Build Speed:</span> <span class="stat-value" id="buildSpeed">0</span> <span class="stat-label">blocks/sec</span></div>
    </div>
    
    <div class="upgrade-section">
        <h3>ðŸ§™ Upgrades</h3>
        <div class="upgrade-card">
            <div class="upgrade-info">
                <div><span class="stat-label">Assistants:</span> <span class="stat-value" id="assistantCount">0</span></div>
                <div><span class="stat-label">Potions Found by Assistants:</span> <span class="stat-value" id="potionsFromAssistants">0</span></div>
                <div><span class="stat-label">Undiscovered Potions:</span> <span class="stat-value" id="undiscoveredCount">0</span></div>
            </div>
            <button class="upgrade-btn" id="buyAssistantBtn" onclick="buyAssistant()">
                Hire Assistant (<span id="assistantCost">100</span> blocks)
            </button>
            <div class="upgrade-desc">Each assistant discovers 1 potion every 5 seconds from your unlocked ingredients.</div>
        </div>
    </div>
</div>

    <script>
      // ========== TOWER SYSTEM ==========
      const TOWER_CONFIG = {
          blockSize: 10,
          towerWidth: 30,        // blocks
          viewportHeight: 80,    // blocks visible
          saveInterval: 30000,   // 30 seconds
          speedPerPotion: 1.1
      };

      let towerState = {
          totalBlocks: 0,        // Total blocks ever placed (can be huge)
          spendableBlocks: 0,    // Blocks available to spend on upgrades
          currentRowProgress: 0, // How many blocks in the current row (0-29)
          visibleRows: [],       // Array of rows currently on screen
          lastUpdateTime: null,
          accumulatedBlocks: 0,  // Fractional blocks accumulated
          towersCompleted: 0,    // How many times tower has been cleared
          assistants: 0,         // Number of potion-finding assistants
          assistantAccumulator: 0, // Time accumulator for assistant work
          potionsFromAssistants: 0, // Track how many potions assistants found
          hasWon: false          // Track if player has hit 1 million blocks
      };

      let towerCanvas, towerCtx;
      let towerAnimationId = null;
      let lastTowerSave = Date.now();

      // Initialize tower
      function initTower() {
          towerCanvas = document.getElementById('towerCanvas');
          if (!towerCanvas) {
              console.warn('Tower canvas not found - make sure #towerPage HTML is added');
              return;
          }
          
          towerCtx = towerCanvas.getContext('2d');
          towerCanvas.width = TOWER_CONFIG.towerWidth * TOWER_CONFIG.blockSize;
          towerCanvas.height = TOWER_CONFIG.viewportHeight * TOWER_CONFIG.blockSize;
          
          // Load tower state from save
          loadTowerState();
          
          // Start the tower loop (runs in background)
          towerState.lastUpdateTime = performance.now();
          requestAnimationFrame(towerLoop);
          
          // Initial render only if elements exist
          renderTower();
          if (document.getElementById('towerHeight')) {
              updateTowerStats();
          }
          if (document.getElementById('buyAssistantBtn')) {
              updateUpgradeUI();
          }
      }

      function loadTowerState() {
          try {
              const saved = localStorage.getItem(STORAGE_KEY);
              if (saved) {
                  const data = JSON.parse(saved);
                  if (data.tower) {
                      towerState.totalBlocks = data.tower.totalBlocks || 0;
                      towerState.spendableBlocks = data.tower.spendableBlocks || 0;
                      towerState.currentRowProgress = data.tower.currentRowProgress || 0;
                      towerState.visibleRows = data.tower.visibleRows || [];
                      towerState.accumulatedBlocks = data.tower.accumulatedBlocks || 0;
                      towerState.towersCompleted = data.tower.towersCompleted || 0;
                      towerState.assistants = data.tower.assistants || 0;
                      towerState.assistantAccumulator = data.tower.assistantAccumulator || 0;
                      towerState.potionsFromAssistants = data.tower.potionsFromAssistants || 0;
                      towerState.hasWon = data.tower.hasWon || false;
                  }
              }
          } catch (e) {
              console.error('Error loading tower state:', e);
          }
      }

      function saveTowerState() {
          try {
              const saved = localStorage.getItem(STORAGE_KEY);
              let data = saved ? JSON.parse(saved) : {};
              
              data.tower = {
                  totalBlocks: towerState.totalBlocks,
                  spendableBlocks: towerState.spendableBlocks,
                  currentRowProgress: towerState.currentRowProgress,
                  visibleRows: towerState.visibleRows,
                  accumulatedBlocks: towerState.accumulatedBlocks,
                  towersCompleted: towerState.towersCompleted,
                  assistants: towerState.assistants,
                  assistantAccumulator: towerState.assistantAccumulator,
                  potionsFromAssistants: towerState.potionsFromAssistants,
                  hasWon: towerState.hasWon
              };
              
              // Preserve other save data
              data.unlockedIngredients = state.unlockedIngredients;
              data.foundWords = state.foundWords;
              data.potions = state.potions;
              data.version = '1.1';
              data.savedAt = new Date().toISOString();
              
              localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
          } catch (e) {
              console.error('Error saving tower state:', e);
          }
      }

      function getBuildSpeed() {
          const potionCount = state.potions ? state.potions.length : 0;
          return potionCount * TOWER_CONFIG.speedPerPotion;
      }

      // ========== ASSISTANT SYSTEM ==========
      const ASSISTANT_CONFIG = {
          baseCost: 1000,
          costMultiplier: 8,
          discoveryInterval: 5 // seconds per potion per assistant
      };

      function getAssistantCost() {
          return ASSISTANT_CONFIG.baseCost * Math.pow(ASSISTANT_CONFIG.costMultiplier, towerState.assistants);
      }

      function canBuyAssistant() {
          return towerState.spendableBlocks >= getAssistantCost();
      }

      function buyAssistant() {
          const cost = getAssistantCost();
          if (towerState.spendableBlocks >= cost) {
              towerState.spendableBlocks -= cost;
              towerState.assistants++;
              updateTowerStats();
              updateUpgradeUI();
              saveTowerState();
          }
      }

      function getUndiscoveredPotions() {
          // Get all possible combinations of 3 unlocked ingredients
          const unlocked = state.unlockedIngredients || [];
          if (unlocked.length < 3) return [];
          
          const undiscovered = [];
          
          for (let i = 0; i < unlocked.length - 2; i++) {
              for (let j = i + 1; j < unlocked.length - 1; j++) {
                  for (let k = j + 1; k < unlocked.length; k++) {
                      const ingredients = [unlocked[i], unlocked[j], unlocked[k]];
                      const key = generatePotionKey(ingredients);
                      
                      // Check if this potion hasn't been made yet
                      const alreadyMade = state.potions.some(p => p.key === key);
                      if (!alreadyMade) {
                          undiscovered.push(ingredients);
                      }
                  }
              }
          }
          
          return undiscovered;
      }

      function assistantDiscoverPotion() {
          const undiscovered = getUndiscoveredPotions();
          if (undiscovered.length === 0) return false;
          
          // Pick a random undiscovered potion
          const randomIndex = Math.floor(Math.random() * undiscovered.length);
          const ingredients = undiscovered[randomIndex];
          
          const potion = generatePotion(ingredients);
          state.potions.unshift(potion);
          towerState.potionsFromAssistants++;
          
          saveProgress(); // Save the new potion
          renderPotions(); // Update the potions list UI
          
          return true;
      }

      function processAssistants(deltaTime) {
          if (towerState.assistants <= 0) return;
          
          const undiscovered = getUndiscoveredPotions();
          if (undiscovered.length === 0) return; // Nothing left to discover
          
          // Each assistant finds 1 potion every 5 seconds
          towerState.assistantAccumulator += deltaTime * towerState.assistants;
          
          while (towerState.assistantAccumulator >= ASSISTANT_CONFIG.discoveryInterval) {
              towerState.assistantAccumulator -= ASSISTANT_CONFIG.discoveryInterval;
              
              if (!assistantDiscoverPotion()) {
                  // No more potions to discover
                  towerState.assistantAccumulator = 0;
                  break;
              }
          }
      }

      function updateUpgradeUI() {
          const upgradeBtn = document.getElementById('buyAssistantBtn');
          const assistantCountEl = document.getElementById('assistantCount');
          const potionsFromAssistantsEl = document.getElementById('potionsFromAssistants');
          const undiscoveredCountEl = document.getElementById('undiscoveredCount');
          
          if (!upgradeBtn || !assistantCountEl || !potionsFromAssistantsEl || !undiscoveredCountEl) return;
          
          const cost = getAssistantCost();
          const canBuy = canBuyAssistant();
          const undiscovered = getUndiscoveredPotions();
          
          assistantCountEl.textContent = towerState.assistants;
          potionsFromAssistantsEl.textContent = formatLargeNumber(towerState.potionsFromAssistants);
          undiscoveredCountEl.textContent = formatLargeNumber(undiscovered.length);
          
          if (undiscovered.length === 0) {
              upgradeBtn.textContent = 'All Potions Discovered!';
              upgradeBtn.disabled = true;
          } else {
              upgradeBtn.textContent = `Hire Assistant (${formatLargeNumber(cost)} blocks)`;
              upgradeBtn.disabled = !canBuy;
          }
      }

      // ========== TOWER LOOP ==========
      function towerLoop(currentTime) {
          if (!towerState.lastUpdateTime) {
              towerState.lastUpdateTime = currentTime;
          }
          
          const deltaTime = (currentTime - towerState.lastUpdateTime) / 1000; // seconds
          towerState.lastUpdateTime = currentTime;
          
          const speed = getBuildSpeed();
          
          if (speed > 0) {
              // Accumulate fractional blocks
              towerState.accumulatedBlocks += speed * deltaTime;
              
              // Place whole blocks
              while (towerState.accumulatedBlocks >= 1) {
                  placeBlock();
                  towerState.accumulatedBlocks -= 1;
              }
          }
          
          // Process assistants
          processAssistants(deltaTime);
          
          // Periodic save
          if (Date.now() - lastTowerSave > TOWER_CONFIG.saveInterval) {
              saveTowerState();
              lastTowerSave = Date.now();
          }
          
          // Update display if tower tab is visible
          if (document.getElementById('towerPage').classList.contains('active')) {
              renderTower();
              updateTowerStats();
              updateUpgradeUI();
          }
          
          towerAnimationId = requestAnimationFrame(towerLoop);
      }

      function placeBlock() {
          towerState.totalBlocks++;
          towerState.spendableBlocks++;
          
          // Check for win condition
          if (!towerState.hasWon && towerState.totalBlocks >= 1000000) {
              towerState.hasWon = true;
              showWinCelebration();
              saveTowerState();
          }
          
          // Ensure we have a current row
          if (towerState.visibleRows.length === 0) {
              towerState.visibleRows.push(new Array(TOWER_CONFIG.towerWidth).fill(false));
          }
          
          // Get current row (top of tower)
          let currentRow = towerState.visibleRows[towerState.visibleRows.length - 1];
          
          // Place block at current position
          currentRow[towerState.currentRowProgress] = true;
          towerState.currentRowProgress++;
          
          // Check if row is complete
          if (towerState.currentRowProgress >= TOWER_CONFIG.towerWidth) {
              towerState.currentRowProgress = 0;
              
              // Add new row
              towerState.visibleRows.push(new Array(TOWER_CONFIG.towerWidth).fill(false));
              
              // Clear tower visually when it fills up (but keep total count)
              if (towerState.visibleRows.length > TOWER_CONFIG.viewportHeight) {
                  towerState.visibleRows = [];
                  towerState.towersCompleted = (towerState.towersCompleted || 0) + 1;
              }
          }
      }

      function renderTower() {
          if (!towerCtx) return;
          
          const ctx = towerCtx;
          const blockSize = TOWER_CONFIG.blockSize;
          
          // Clear canvas with gradient background
          const gradient = ctx.createLinearGradient(0, 0, 0, towerCanvas.height);
          gradient.addColorStop(0, '#0d0d1a');
          gradient.addColorStop(1, '#1a1a2e');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, towerCanvas.width, towerCanvas.height);
          
          // Draw blocks from bottom to top
          const rowCount = towerState.visibleRows.length;
          
          for (let rowIdx = 0; rowIdx < rowCount; rowIdx++) {
              const row = towerState.visibleRows[rowIdx];
              // Draw from bottom of canvas
              const y = towerCanvas.height - (rowIdx + 1) * blockSize;
              
              for (let colIdx = 0; colIdx < row.length; colIdx++) {
                  if (row[colIdx]) {
                      const x = colIdx * blockSize;
                      
                      // Block fill
                      ctx.fillStyle = '#6a6a8a';
                      ctx.fillRect(x, y, blockSize - 1, blockSize - 1);
                      
                      // Subtle highlight
                      ctx.fillStyle = '#8a8aaa';
                      ctx.fillRect(x, y, blockSize - 1, 2);
                      ctx.fillRect(x, y, 2, blockSize - 1);
                      
                      // Subtle shadow
                      ctx.fillStyle = '#4a4a6a';
                      ctx.fillRect(x + blockSize - 3, y + 2, 2, blockSize - 3);
                      ctx.fillRect(x + 2, y + blockSize - 3, blockSize - 3, 2);
                  }
              }
          }
      }

      function formatLargeNumber(num) {
          if (num < 1000000) {
              return num.toLocaleString();
          }
          
          const exp = Math.floor(Math.log10(num));
          const mantissa = num / Math.pow(10, exp);
          return `${mantissa.toFixed(2)} Ã— 10^${exp}`;
      }

      function showWinCelebration() {
          // Create overlay
          const overlay = document.createElement('div');
          overlay.id = 'winOverlay';
          overlay.innerHTML = `
              <div class="win-modal">
                  <div class="win-sparkles">âœ¨</div>
                  <h2>ðŸŽ‰ Congratulations! ðŸŽ‰</h2>
                  <p>You've built <span class="win-highlight">1,000,000 blocks!</span></p>
                  <p class="win-subtitle">Your tower has reached legendary heights!</p>
                  <div class="win-stats">
                      <div>Towers Completed: ${towerState.towersCompleted}</div>
                      <div>Potions Brewed: ${state.potions ? state.potions.length : 0}</div>
                      <div>Assistants Hired: ${towerState.assistants}</div>
                  </div>
                  <button class="win-btn" onclick="closeWinCelebration()">Continue Building</button>
              </div>
          `;
          document.body.appendChild(overlay);
      }

      function closeWinCelebration() {
          const overlay = document.getElementById('winOverlay');
          if (overlay) {
              overlay.remove();
          }
      }

      function updateTowerStats() {
          const heightEl = document.getElementById('towerHeight');
          const blocksEl = document.getElementById('totalBlocks');
          const spendableEl = document.getElementById('spendableBlocks');
          const speedEl = document.getElementById('buildSpeed');
          const towersEl = document.getElementById('towersCompleted');
          
          if (!heightEl) return;
          
          // Calculate total rows (including partial)
          const completedRows = Math.floor(towerState.totalBlocks / TOWER_CONFIG.towerWidth);
          
          heightEl.textContent = formatLargeNumber(completedRows);
          blocksEl.textContent = formatLargeNumber(towerState.totalBlocks);
          if (spendableEl) spendableEl.textContent = formatLargeNumber(towerState.spendableBlocks);
          speedEl.textContent = getBuildSpeed().toFixed(1);
          towersEl.textContent = formatLargeNumber(towerState.towersCompleted || 0);
      }

      // Update the switchTab function to handle tower tab
      const originalSwitchTab = typeof switchTab === 'function' ? switchTab : null;
      switchTab = function(tab) {
          document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
          document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          
          if (tab === 'search') {
              document.getElementById('searchPage').classList.add('active');
              document.querySelectorAll('.tab-btn')[0].classList.add('active');
          } else if (tab === 'mixer') {
              document.getElementById('mixerPage').classList.add('active');
              document.querySelectorAll('.tab-btn')[1].classList.add('active');
          } else if (tab === 'tower') {
              document.getElementById('towerPage').classList.add('active');
              document.querySelectorAll('.tab-btn')[2].classList.add('active');
              renderTower();
              updateTowerStats();
              updateUpgradeUI();
          }
      };

      // Update loadProgress to also load tower state
      const originalLoadProgress = typeof loadProgress === 'function' ? loadProgress : null;
      if (originalLoadProgress) {
          const _origLoadProgress = loadProgress;
          loadProgress = function() {
              const result = _origLoadProgress();
              loadTowerState();
              return result;
          };
      }

      // Update initializeGame to init tower
      const originalInitializeGame = typeof initializeGame === 'function' ? initializeGame : null;
      if (originalInitializeGame) {
          const _origInitializeGame = initializeGame;
          initializeGame = function() {
              _origInitializeGame();
              initTower();
          };
      }

      // Save tower state when page unloads
      window.addEventListener('beforeunload', () => {
          saveTowerState();
      });
        // ========== GLOBAL DATA ==========
        let INGREDIENTS_DATA = [];
        let POTIONS_DATA = {};
        let TOTAL_POSSIBLE_POTIONS = 0;

        // ========== GAME STATE ==========
        const GRID_SIZE = 15;
        const INGREDIENTS_PER_PUZZLE = 5;
        const DIRECTIONS = [
            [0, 1], [1, 0], [1, 1], [-1, 1],
            [0, -1], [-1, 0], [-1, -1], [1, -1]
        ];

        let state = {
            selectedIngredients: [],
            potions: [],
            unlockedIngredients: [],
            foundWords: [],
            grid: [],
            wordPositions: {},
            currentSelection: [],
            currentPuzzleWords: []
        };

        // ========== LOCAL STORAGE PERSISTENCE ==========
        const STORAGE_KEY = 'witchyPotionMixer_saveData';

        function saveProgress() {
            const saveData = {
                unlockedIngredients: state.unlockedIngredients,
                foundWords: state.foundWords,
                potions: state.potions,
                version: '1.0',
                savedAt: new Date().toISOString()
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
            console.log('Progress saved:', saveData);
        }

        function loadProgress() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) {
                    console.log('No saved progress found');
                    return false;
                }
                
                const saveData = JSON.parse(saved);
                console.log('Loading saved progress:', saveData);
                
                state.unlockedIngredients = saveData.unlockedIngredients || [];
                state.foundWords = saveData.foundWords || [];
                state.potions = saveData.potions || [];
                
                console.log('Progress loaded successfully');
                return true;
            } catch (error) {
                console.error('Error loading saved progress:', error);
                return false;
            }
        }

        function clearProgress() {
            if (confirm('Are you sure you want to clear all progress? This cannot be undone.')) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        }

        // ========== DATA LOADING ==========
        async function loadData() {
            try {
                // Try loading ingredients
                const ingredientsRes = await fetch('ingredients_data.json');
                if (!ingredientsRes.ok) {
                    throw new Error(`Failed to load ingredients_data.json: ${ingredientsRes.status}`);
                }
                const ingredientsText = await ingredientsRes.text();
                console.log('Ingredients file loaded, length:', ingredientsText.length);
                console.log('First 100 chars:', ingredientsText.substring(0, 100));
                INGREDIENTS_DATA = JSON.parse(ingredientsText);
                console.log('Ingredients parsed successfully:', INGREDIENTS_DATA.length, 'items');
                
                // Try loading potions
                const potionsRes = await fetch('potions_data.json');
                if (!potionsRes.ok) {
                    throw new Error(`Failed to load potions_data.json: ${potionsRes.status}`);
                }
                const potionsText = await potionsRes.text();
                console.log('Potions file loaded, length:', potionsText.length);
                console.log('First 100 chars:', potionsText.substring(0, 100));
                POTIONS_DATA = JSON.parse(potionsText);
                console.log('Potions parsed successfully:', Object.keys(POTIONS_DATA).length, 'potions');
                
                TOTAL_POSSIBLE_POTIONS = Object.keys(POTIONS_DATA).length;
                
                initializeGame();
            } catch (error) {
                console.error('Error loading data files:', error);
                alert(`Error loading game data: ${error.message}\n\nCheck the browser console (F12) for details.\n\nMake sure:\n1. Files are named exactly: ingredients_data.json and potions_data.json\n2. Files are valid JSON (no trailing commas, use double quotes)\n3. Files are in the same directory as index.html`);
            }
        }

        function initializeGame() {
            loadProgress(); // Load saved progress first
            createGrid();
            renderGrid();
            updateWordsList();
            updateMixerUI();
        }

        // ========== POTION GENERATION ==========
        function getIngredientIndices(ingredients) {
            return ingredients
                .map(ing => INGREDIENTS_DATA.indexOf(ing))
                .sort((a, b) => a - b);
        }

        function generatePotionKey(ingredients) {
            const indices = getIngredientIndices(ingredients);
            return indices.join('-');
        }

        function generatePotion(ingredients) {
            const sorted = [...ingredients].sort();
            const key = generatePotionKey(ingredients);
            
            if (POTIONS_DATA[key]) {
                return {
                    name: POTIONS_DATA[key].name,
                    description: POTIONS_DATA[key].description,
                    ingredients: sorted,
                    key: key
                };
            }
            
            const hash = hashString(sorted.join('|'));
            
            const prefixes = ['Elixir of', 'Draught of', 'Brew of', 'Tonic of', 'Essence of'];
            const qualities = ['Whispering', 'Eternal', 'Forbidden', 'Ancient', 'Midnight'];
            const nouns = ['Dreams', 'Secrets', 'Visions', 'Wisdom', 'Power'];
            
            const prefix = prefixes[hash % prefixes.length];
            const quality = qualities[Math.floor(hash / 10) % qualities.length];
            const noun = nouns[Math.floor(hash / 100) % nouns.length];
            
            return {
                name: `${prefix} ${quality} ${noun}`,
                description: `A mysterious concoction combining ${sorted[0].toLowerCase()}, ${sorted[1].toLowerCase()}, and ${sorted[2].toLowerCase()}. Its true properties remain unknown to modern witches.`,
                ingredients: sorted,
                key: key
            };
        }

        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        // ========== COMBO CHECKING ==========
        function isPotionAlreadyMade(ingredient) {
            if (state.selectedIngredients.length === 0) return false;
            
            const testIngredients = [...state.selectedIngredients, ingredient].sort();
            if (testIngredients.length < 3) return false;
            
            const testKey = generatePotionKey(testIngredients);
            return state.potions.some(p => p.key === testKey);
        }

        function getDiscoveredCount() {
            return state.potions.length;
        }

        // ========== UI FUNCTIONS ==========
        function switchTab(tab) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            
            if (tab === 'search') {
                document.getElementById('searchPage').classList.add('active');
                document.querySelectorAll('.tab-btn')[0].classList.add('active');
            } else {
                document.getElementById('mixerPage').classList.add('active');
                document.querySelectorAll('.tab-btn')[1].classList.add('active');
            }
        }

        function regenerateGrid() {
            createGrid();
            renderGrid();
            updateWordsList();
        }

        // ========== WORD SEARCH LOGIC ==========
        function createGrid() {
            const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(''));
            const positions = {};

            const remainingIngredients = INGREDIENTS_DATA.filter(ing => !state.unlockedIngredients.includes(ing));
            
            const shuffled = [...remainingIngredients]
                .sort(() => Math.random() - 0.5)
                .slice(0, Math.min(INGREDIENTS_PER_PUZZLE, remainingIngredients.length));

            state.currentPuzzleWords = shuffled;

            shuffled.forEach(ingredient => {
                const words = ingredient.toUpperCase().split(' ');
                
                words.forEach(word => {
                    let placed = false;
                    let attempts = 0;

                    while (!placed && attempts < 200) {
                        const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
                        const row = Math.floor(Math.random() * GRID_SIZE);
                        const col = Math.floor(Math.random() * GRID_SIZE);

                        if (canPlaceWord(grid, word, row, col, dir)) {
                            placeWord(grid, word, row, col, dir, positions);
                            placed = true;
                        }
                        attempts++;
                    }
                });
            });

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] === '') {
                        grid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }
            }

            state.grid = grid;
            state.wordPositions = positions;
        }

        function canPlaceWord(grid, word, row, col, dir) {
            for (let i = 0; i < word.length; i++) {
                const newRow = row + dir[0] * i;
                const newCol = col + dir[1] * i;

                if (newRow < 0 || newRow >= GRID_SIZE || newCol < 0 || newCol >= GRID_SIZE) {
                    return false;
                }

                if (grid[newRow][newCol] !== '' && grid[newRow][newCol] !== word[i]) {
                    return false;
                }
            }
            return true;
        }

        function placeWord(grid, word, row, col, dir, positions) {
            const coords = [];
            for (let i = 0; i < word.length; i++) {
                const newRow = row + dir[0] * i;
                const newCol = col + dir[1] * i;
                grid[newRow][newCol] = word[i];
                coords.push([newRow, newCol]);
            }
            positions[word] = coords;
        }

        function renderGrid() {
            const gridEl = document.getElementById('wordGrid');
            gridEl.innerHTML = '';

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = state.grid[i][j];
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    cell.addEventListener('mousedown', startSelection);
                    cell.addEventListener('mouseenter', continueSelection);
                    cell.addEventListener('mouseup', endSelection);
                    cell.addEventListener('touchstart', handleTouchStart);
                    cell.addEventListener('touchmove', handleTouchMove);
                    cell.addEventListener('touchend', endSelection);
                    
                    gridEl.appendChild(cell);
                }
            }
        }

        function handleTouchStart(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const target = document.elementFromPoint(touch.clientX, touch.clientY);
          if (target && target.dataset.row !== undefined) {
              const row = parseInt(target.dataset.row);
              const col = parseInt(target.dataset.col);
              touchStartCell = { row, col };
              state.currentSelection = [[row, col]];
              
              // Clear previous selection styling
              document.querySelectorAll('.grid-cell.selected').forEach(cell => {
                  if (!cell.classList.contains('found')) {
                      cell.classList.remove('selected');
                  }
              });
              
              target.classList.add('selected');
          }
      }

      function handleTouchMove(e) {
          e.preventDefault();
          if (!touchStartCell) return;
          
          const touch = e.touches[0];
          const target = document.elementFromPoint(touch.clientX, touch.clientY);
          
          if (!target || target.dataset.row === undefined) return;
          
          const currentRow = parseInt(target.dataset.row);
          const currentCol = parseInt(target.dataset.col);
          const startRow = touchStartCell.row;
          const startCol = touchStartCell.col;
          
          // Calculate direction from start to current position
          const dRow = currentRow - startRow;
          const dCol = currentCol - startCol;
          
          // If we haven't moved, just show starting cell
          if (dRow === 0 && dCol === 0) {
              state.currentSelection = [[startRow, startCol]];
              updateTouchSelection();
              return;
          }
          
          // Calculate the angle from start to current position
          const angle = Math.atan2(dRow, dCol);
          
          // Define the 8 possible directions with their angles
          const directions = [
              { row: 0, col: 1, angle: 0 },                    // East
              { row: 1, col: 1, angle: Math.PI / 4 },          // Southeast
              { row: 1, col: 0, angle: Math.PI / 2 },          // South
              { row: 1, col: -1, angle: 3 * Math.PI / 4 },     // Southwest
              { row: 0, col: -1, angle: Math.PI },             // West
              { row: -1, col: -1, angle: -3 * Math.PI / 4 },   // Northwest
              { row: -1, col: 0, angle: -Math.PI / 2 },        // North
              { row: -1, col: 1, angle: -Math.PI / 4 }         // Northeast
          ];
          
          // Find the direction with the smallest angular difference
          let bestDirection = directions[0];
          let smallestDiff = Math.PI;
          
          for (const dir of directions) {
              let diff = Math.abs(angle - dir.angle);
              // Handle wraparound (e.g., -Ï€ and Ï€ are the same)
              if (diff > Math.PI) diff = 2 * Math.PI - diff;
              
              if (diff < smallestDiff) {
                  smallestDiff = diff;
                  bestDirection = dir;
              }
          }
          
          // Build the selection path from start in the best direction
          state.currentSelection = [[startRow, startCol]];
          
          // Calculate how many steps to take based on distance
          const steps = Math.max(Math.abs(dRow), Math.abs(dCol));
          
          for (let i = 1; i <= steps; i++) {
              const newRow = startRow + (bestDirection.row * i);
              const newCol = startCol + (bestDirection.col * i);
              
              // Check if still in bounds
              if (newRow < 0 || newRow >= GRID_SIZE || newCol < 0 || newCol >= GRID_SIZE) {
                  break;
              }
              
              state.currentSelection.push([newRow, newCol]);
          }
          
          updateTouchSelection();
      }

      function updateTouchSelection() {
          // Clear all non-found selected cells
          document.querySelectorAll('.grid-cell.selected').forEach(cell => {
              if (!cell.classList.contains('found')) {
                  cell.classList.remove('selected');
              }
          });
          
          // Apply selection to current path
          state.currentSelection.forEach(([r, c]) => {
              const cell = document.querySelector(`[data-row='${r}'][data-col='${c}']`);
              if (cell) cell.classList.add('selected');
          });
      }

        function startSelection(e) {
            state.currentSelection = [[parseInt(e.target.dataset.row), parseInt(e.target.dataset.col)]];
            e.target.classList.add('selected');
        }

        function continueSelection(e) {
            if (state.currentSelection.length === 0 || e.buttons !== 1) return;
            
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const start = state.currentSelection[0];
            
            // Calculate direction from start to current position
            const dRow = row - start[0];
            const dCol = col - start[1];
            
            // If we haven't moved, don't do anything
            if (dRow === 0 && dCol === 0) return;
            
            // Calculate the angle from start to current position
            const angle = Math.atan2(dRow, dCol);
            
            // Define the 8 possible directions with their angles
            const directions = [
                { row: 0, col: 1, angle: 0 },                    // East
                { row: 1, col: 1, angle: Math.PI / 4 },          // Southeast
                { row: 1, col: 0, angle: Math.PI / 2 },          // South
                { row: 1, col: -1, angle: 3 * Math.PI / 4 },     // Southwest
                { row: 0, col: -1, angle: Math.PI },             // West
                { row: -1, col: -1, angle: -3 * Math.PI / 4 },   // Northwest
                { row: -1, col: 0, angle: -Math.PI / 2 },        // North
                { row: -1, col: 1, angle: -Math.PI / 4 }         // Northeast
            ];
            
            // Find the direction with the smallest angular difference
            let bestDirection = directions[0];
            let smallestDiff = Math.PI;
            
            for (const dir of directions) {
                let diff = Math.abs(angle - dir.angle);
                // Handle wraparound (e.g., -Ï€ and Ï€ are the same)
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                
                if (diff < smallestDiff) {
                    smallestDiff = diff;
                    bestDirection = dir;
                }
            }
            
            // Clear previous selection visually
            document.querySelectorAll('.grid-cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
            
            // Build the complete path from start to current position
            state.currentSelection = [start];
            let currentRow = start[0];
            let currentCol = start[1];
            
            // Calculate how many steps to take
            const steps = Math.max(Math.abs(dRow), Math.abs(dCol));
            
            for (let i = 1; i <= steps; i++) {
                currentRow = start[0] + (bestDirection.row * i);
                currentCol = start[1] + (bestDirection.col * i);
                
                // Check if still in bounds
                const cell = document.querySelector(`[data-row='${currentRow}'][data-col='${currentCol}']`);
                if (!cell) break;
                
                state.currentSelection.push([currentRow, currentCol]);
            }
            
            // Apply selection styling
            state.currentSelection.forEach(([r, c]) => {
                const cell = document.querySelector(`[data-row='${r}'][data-col='${c}']`);
                if (cell) cell.classList.add('selected');
            });
        }

        
        function endSelection() {
            if (state.currentSelection.length > 0) {
                checkWord();
                clearSelection();
            }
            touchStartCell = null; // Reset touch start
        }

        function clearSelection() {
            document.querySelectorAll('.grid-cell.selected').forEach(cell => {
                if (!cell.classList.contains('found')) {
                    cell.classList.remove('selected');
                }
            });
            state.currentSelection = [];
            touchStartCell = null;
        }

        function checkWord() {
            const word = state.currentSelection.map(([r, c]) => state.grid[r][c]).join('');
            const wordReverse = word.split('').reverse().join('');

            state.currentPuzzleWords.forEach(ingredient => {
                const words = ingredient.toUpperCase().split(' ');
                
                words.forEach(subWord => {
                    if ((word === subWord || wordReverse === subWord) && state.wordPositions[subWord]) {
                        const positions = state.wordPositions[subWord];
                        positions.forEach(([r, c]) => {
                            const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (cell) cell.classList.add('found');
                        });

                        delete state.wordPositions[subWord];

                        const allWordsFound = ingredient.toUpperCase().split(' ').every(w => !state.wordPositions[w]);
                        
                        if (allWordsFound && !state.foundWords.includes(ingredient)) {
                            state.foundWords.push(ingredient);
                            state.unlockedIngredients.push(ingredient);
                            saveProgress(); // Save when ingredient unlocked
                            updateWordsList();
                            updateMixerUI();
                        }
                    }
                });
            });
        }

        function updateWordsList() {
            const listEl = document.getElementById('wordsList');
            
            if (state.currentPuzzleWords.length === 0) {
                listEl.innerHTML = '<div class="empty-state">All ingredients found! Generate a new puzzle.</div>';
                return;
            }

            listEl.innerHTML = state.currentPuzzleWords.map(ing => {
                const found = state.foundWords.includes(ing);
                return `<div class="word-item ${found ? 'found' : ''}">${ing}</div>`;
            }).join('');

            document.getElementById('progressText').textContent = 
                `Total Found: ${state.unlockedIngredients.length} / ${INGREDIENTS_DATA.length}`;
        }

        // ========== MIXER FUNCTIONS ==========
        function toggleIngredient(ingredient) {
            if (!state.unlockedIngredients.includes(ingredient)) return;

            const idx = state.selectedIngredients.indexOf(ingredient);
            
            if (idx > -1) {
                state.selectedIngredients.splice(idx, 1);
            } else {
                if (state.selectedIngredients.length < 3) {
                    state.selectedIngredients.push(ingredient);
                }
            }
            
            updateMixerUI();
        }

        function mixPotion() {
            if (state.selectedIngredients.length === 0) return;

            const potion = generatePotion(state.selectedIngredients);
            const exists = state.potions.some(p => p.key === potion.key);
            
            if (!exists) {
                state.potions.unshift(potion);
                saveProgress(); // Save when potion created
            }

            state.selectedIngredients = [];
            updateMixerUI();
        }

        function renderPotions() {
            const list = document.getElementById('potionList');
            const countEl = document.getElementById('potionCount');
            
            countEl.textContent = `(${getDiscoveredCount()} / ${TOTAL_POSSIBLE_POTIONS})`;
            
            if (state.potions.length === 0) {
                list.innerHTML = '<div class="empty-state">No potions brewed yet. Unlock ingredients and mix!</div>';
                return;
            }

            list.innerHTML = state.potions.map(potion => `
                <div class="potion-card">
                    <div class="potion-name">${potion.name}</div>
                    <div class="potion-desc">${potion.description}</div>
                    <div class="potion-ingredients">Ingredients: ${potion.ingredients.join(', ')}</div>
                    <div class="debug-key">Key: ${potion.key}</div>
                </div>
            `).join('');
        }

        function updateMixerUI() {
            const grid = document.getElementById('ingredientsGrid');
            const mixBtn = document.getElementById('mixButton');
            
            grid.innerHTML = INGREDIENTS_DATA.map(ing => {
                const unlocked = state.unlockedIngredients.includes(ing);
                const selected = state.selectedIngredients.includes(ing);
                const disabled = !selected && state.selectedIngredients.length >= 3;
                const alreadyMade = unlocked && !selected && isPotionAlreadyMade(ing);
                
                return `
                    <button 
                        class="ingredient-btn ${selected ? 'selected' : ''} ${disabled ? 'disabled' : ''} ${!unlocked ? 'locked' : ''} ${alreadyMade ? 'already-made' : ''}"
                        onclick="toggleIngredient('${ing}')"
                        ${disabled || !unlocked ? 'disabled' : ''}
                    >
                        ${unlocked ? ing : ''}
                    </button>
                `;
            }).join('');

            mixBtn.disabled = state.selectedIngredients.length === 0;
            renderPotions();
        }

        // ========== EXPORT FUNCTIONS ==========
        function loseState() {
            return {
                ingredients: INGREDIENTS_DATA,
                unlockedIngredients: state.unlockedIngredients,
                potions: state.potions,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
        }

        function caesarCipher(text, shift) {
            return text.split('').map(char => {
                const code = char.charCodeAt(0);
                if (code >= 65 && code <= 90) {
                    return String.fromCharCode(((code - 65 + shift) % 26) + 65);
                } else if (code >= 97 && code <= 122) {
                    return String.fromCharCode(((code - 97 + shift) % 26) + 97);
                }
                return char;
            }).join('');
        }

        function xorEncrypt(text, key) {
            return btoa(text.split('').map((char, i) => 
                String.fromCharCode(char.charCodeAt(0) ^ key.charCodeAt(i % key.length))
            ).join(''));
        }

        function exportEncrypted() {
            const stateData = loseState();
            const json = JSON.stringify(stateData);
            const encrypted = xorEncrypt(caesarCipher(json, 13), 'witchypotion');
            
            const blob = new Blob([encrypted], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'potions_encrypted.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportDummy() {
            const stateData = loseState();
            const json = JSON.stringify(stateData, null, 2);
            
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'potions_plain.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // ========== INITIALIZATION ==========
        document.getElementById('mixButton').addEventListener('click', mixPotion);

        // Load data and start game
        loadData();
    </script>
</body>
</html>